Assignment Notes

don't change the name of the functions

3 classes:
- bst
- node 
    should store the key and the value in a pair
- iterator
    return std::pairs
    outside the class
    template on node_type


If the user wants to update a value with a key that is already in the tree, we have to build an interface for this. Othrwise the default is to not update.

template <typename kt, typename vt, typename cmp =  (DEFAULT) std::less<kt>   >
class bst{
    cmp op;

    public:
        bst(cmp x): op{x} {}
        using node_type = Node<std::pair<const kt,vt>;
        using iterator = _iterator<nodetype, typename node_type::value_type;>
        using const_iterator = _iterator<nodetype, const typename node_type::value_type;>
}

template <typename T>
class Node {
    T value;
    left (could use unique pointer)
    right (could use unique pointer)
    parent (raw pointer) (root point to null pointer)

    using value_type = T;
}


// const iterator is the same but it must return a const reference!!


template <typename node_type, typename T>
class _iterator {
    nodet_t current;

    public:
        using value_type = T;
        using reference = value_type&;
        using pointer = value_type*;
        using iterator_category ...
        using difference_type = std::ptrdiff_t;

        reference operator*() const {
            return ...
        }
}


t.insert({1,3})
t.emplace(1,3)

Balance???
store the keys in a std vector.
take the middle point and insert
go to the left and take the middle
etc etc

If we want to update and the key is not there we add a new node with key x and value??
insert( {x, vt{} });


// build insert
std::pair<iterator, bool> insert(const kt& x);

//suppose that you want to implement this function utside the class

template <typename kt, typename vt, typename cmp>
std::pair<typename bst<kt,vt,cmp>::iterator, bool> bst<kt,vt,cmp>::insert(const kt& x) {

    //now we are inside of the class again!!!
}


if we want to write code in different file:

inside bst.hpp
#ifndef __bst_hpp
#define __bst_hpp
...
...
class bst {

}
...
...
#endif
#include "functions_bst.hpp"



###################################
#                                 #
#       QUESTIONS                 #
#                                 #
###################################


1. Why is cbegin operating on const? Shouldn't it be operating also on non-const bsts and yield
the same const_iterator?

2. In the subscripting operator we should insert a node if the key doesn't exist. Which value do we have to insert? Input from terminal?

3. Why do we actually need to specify std::move on a parameter passed already as a rvalue reference 
    (see line 18 of as_linked_list.cc, lesson 8)

4. Alberto, why are you using that many templates in the linked list example? 